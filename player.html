<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Premium Movie Player</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
  <style>
    @keyframes spin { 0%{transform:rotate(0)}100%{transform:rotate(360deg)}}
    .loading-spinner{animation:spin 1s linear infinite}
    .video-container{position:relative;padding-bottom:56.25%;height:0;overflow:hidden;background:#000;border-radius:.75rem;box-shadow:0 25px 50px -12px rgba(0,0,0,.5)}
    .video-container video{position:absolute;top:0;left:0;width:100%;height:100%}
    .controls-container{transition:opacity .3s ease}
    .progress-container{height:5px;background:rgba(255,255,255,.2);cursor:pointer}
    .progress-bar{height:100%;background:#f59e0b;transition:width .1s}
    .volume-container{width:0;transition:width .2s ease;overflow:hidden}
    .volume-container.active{width:100px}
    .settings-menu{transform:translateY(20px);opacity:0;transition:all .2s ease;pointer-events:none}
    .settings-menu.active{transform:translateY(0);opacity:1;pointer-events:all}
    .quality-option:hover,.speed-option:hover,.subtitle-option:hover{background-color:rgba(255,255,255,.1)}
    .tooltip{visibility:hidden;opacity:0;transition:opacity .3s}
    .tooltip-parent:hover .tooltip{visibility:visible;opacity:1}
    :fullscreen .video-container, .video-container:fullscreen{padding-bottom:0!important;height:100vh!important;width:100vw!important;border-radius:0!important}
    :fullscreen video, .video-container:fullscreen video{width:100vw!important;height:100vh!important;object-fit:cover}
    @media (max-width:768px){.controls-container{padding:.5rem}.control-btn{padding:.5rem}.volume-container{display:none}.mobile-volume{display:block}}
    /* small info overlay */
    .info-overlay { position: absolute; top: 8px; right: 8px; background: rgba(0,0,0,0.6); color: #fff; padding: 6px 10px; border-radius: 6px; font-size: 13px; z-index: 60; }
  </style>
</head>
<body class="bg-gray-900 text-gray-100 min-h-screen flex flex-col items-center p-4 md:p-8">
  <!-- Loading Overlay -->
  <div id="loading-overlay" class="fixed inset-0 bg-black bg-opacity-90 flex flex-col items-center justify-center z-50">
    <div class="loading-spinner w-16 h-16 border-4 border-gray-200 border-t-amber-400 rounded-full mb-4"></div>
    <p id="loading-text" class="text-xl font-semibold text-amber-400">Loading movie...</p>
    <p id="loading-details" class="text-gray-400 mt-2">Please wait while we prepare your viewing experience</p>
  </div>

  <div class="w-full max-w-6xl">
    <!-- Header -->
    <div class="flex justify-between items-center mb-4 md:mb-6">
      <h1 id="movie-title" class="text-2xl md:text-3xl font-bold text-amber-400 truncate max-w-xs md:max-w-md">Movie Title</h1>
      <a href="" class="flex items-center text-gray-300 hover:text-amber-400 transition">
        <i class="fas fa-arrow-left mr-2"></i>
        <span class="hidden md:inline"></span>
      </a>
    </div>

    <!-- Video Player -->
    <div class="video-container group" id="video-container">
      <video id="video" class="w-full" crossorigin="anonymous" playsinline controlsList="nodownload"></video>

      <div class="info-overlay" id="stream-info" style="display:none"></div>

      <!-- Custom Controls -->
      <div id="controls-container" class="controls-container absolute bottom-0 left-0 right-0 bg-gradient-to-t from-black to-transparent p-4 opacity-0 group-hover:opacity-100">
        <div class="progress-container mb-2" id="progress-container">
          <div class="progress-bar" id="progress-bar"></div>
        </div>

        <div class="flex items-center justify-between">
          <div class="flex items-center space-x-2 md:space-x-4">
            <button id="play-pause" class="control-btn text-white hover:text-amber-400 transition">
              <i class="fas fa-play text-xl"></i>
            </button>
            <button id="rewind" class="control-btn text-white hover:text-amber-400 transition tooltip-parent">
              <i class="fas fa-backward text-lg"></i>
              <span class="tooltip absolute bottom-full mb-2 px-2 py-1 text-xs bg-gray-800 rounded">Rewind 10s</span>
            </button>
            <button id="forward" class="control-btn text-white hover:text-amber-400 transition tooltip-parent">
              <i class="fas fa-forward text-lg"></i>
              <span class="tooltip absolute bottom-full mb-2 px-2 py-1 text-xs bg-gray-800 rounded">Forward 10s</span>
            </button>

            <!-- Volume Controls -->
            <div class="flex items-center">
              <button id="volume-btn" class="control-btn text-white hover:text-amber-400 transition">
                <i class="fas fa-volume-up text-lg"></i>
              </button>
              <div class="volume-container ml-2 flex items-center" id="volume-container">
                <input type="range" id="volume-slider" min="0" max="1" step="0.01" value="1"
                       class="w-full h-1 bg-gray-600 rounded-lg appearance-none cursor-pointer">
              </div>
            </div>

            <!-- Time Display -->
            <div class="text-sm text-gray-300 hidden md:block">
              <span id="current-time">00:00</span> / <span id="duration">00:00</span>
            </div>
          </div>

          <!-- Right Controls -->
          <div class="flex items-center space-x-2 md:space-x-4">
            <!-- Playback Speed -->
            <div class="relative">
              <button id="speed-btn" class="control-btn text-white hover:text-amber-400 transition">
                <span class="text-sm font-medium">1x</span>
              </button>
              <div class="settings-menu absolute bottom-full right-0 mb-2 w-32 bg-gray-800 rounded-md shadow-lg py-1 z-10" id="speed-menu">
                <div class="speed-option px-3 py-2 cursor-pointer" data-speed="0.5">0.5x</div>
                <div class="speed-option px-3 py-2 cursor-pointer" data-speed="0.75">0.75x</div>
                <div class="speed-option px-3 py-2 cursor-pointer" data-speed="1">1x (Normal)</div>
                <div class="speed-option px-3 py-2 cursor-pointer" data-speed="1.25">1.25x</div>
                <div class="speed-option px-3 py-2 cursor-pointer" data-speed="1.5">1.5x</div>
                <div class="speed-option px-3 py-2 cursor-pointer" data-speed="2">2x</div>
              </div>
            </div>

            <!-- Subtitles -->
            <div class="relative">
              <button id="subtitle-btn" class="control-btn text-white hover:text-amber-400 transition">
                <i class="fas fa-closed-captioning text-lg"></i>
              </button>
              <div class="settings-menu absolute bottom-full right-0 mb-2 w-40 bg-gray-800 rounded-md shadow-lg py-1 z-10" id="subtitle-menu">
                <div class="subtitle-option px-3 py-2 cursor-pointer" data-subtitle="none">None</div>
                <div class="subtitle-option px-3 py-2 cursor-pointer" data-subtitle="en">English</div>
              </div>
            </div>

            <!-- Quality -->
            <div class="relative">
              <button id="quality-btn" class="control-btn text-white hover:text-amber-400 transition">
                <i class="fas fa-cog text-lg"></i>
              </button>
              <div class="settings-menu absolute bottom-full right-0 mb-2 w-32 bg-gray-800 rounded-md shadow-lg py-1 z-10" id="quality-menu">
                <div class="quality-option px-3 py-2 cursor-pointer" data-quality="auto">Auto</div>
                <div class="quality-option px-3 py-2 cursor-pointer" data-quality="720">720p</div>
                <div class="quality-option px-3 py-2 cursor-pointer" data-quality="480">480p</div>
                <div class="quality-option px-3 py-2 cursor-pointer" data-quality="360">360p</div>
              </div>
            </div>

            <!-- Fullscreen -->
            <button id="fullscreen-btn" class="control-btn text-white hover:text-amber-400 transition">
              <i class="fas fa-expand text-lg"></i>
            </button>
          </div>
        </div>
      </div>
    </div>

    <!-- Mobile Volume (hidden on desktop) -->
    <div class="mt-2 flex items-center md:hidden" id="mobile-volume">
      <i class="fas fa-volume-down text-gray-400 mr-2"></i>
      <input type="range" id="mobile-volume-slider" min="0" max="1" step="0.01" value="1"
             class="w-full h-1 bg-gray-600 rounded-lg appearance-none cursor-pointer">
      <i class="fas fa-volume-up text-gray-400 ml-2"></i>
    </div>

    <!-- Additional Info -->
    <div class="mt-6 grid grid-cols-1 md:grid-cols-3 gap-6">
      <div class="bg-gray-800 p-4 rounded-lg">
        <h3 class="text-lg font-semibold text-amber-400 mb-2">Playback Information</h3>
        <div class="space-y-2">
          <div class="flex justify-between"><span class="text-gray-400">Current Position:</span><span id="current-position" class="font-medium">00:00</span></div>
          <div class="flex justify-between"><span class="text-gray-400">Remaining Time:</span><span id="remaining-time" class="font-medium">00:00</span></div>
          <div class="flex justify-between"><span class="text-gray-400">Playback Speed:</span><span id="current-speed" class="font-medium">1x</span></div>
          <div class="flex justify-between"><span class="text-gray-400">Quality:</span><span id="current-quality" class="font-medium">Auto</span></div>
        </div>
      </div>

      <div class="bg-gray-800 p-4 rounded-lg">
        <h3 class="text-lg font-semibold text-amber-400 mb-2">Keyboard Shortcuts</h3>
        <div class="space-y-2">
          <div class="flex justify-between"><span class="text-gray-400">Space:</span><span class="font-medium">Play/Pause</span></div>
          <div class="flex justify-between"><span class="text-gray-400">Arrow Left/Right:</span><span class="font-medium">Seek ±10s</span></div>
          <div class="flex justify-between"><span class="text-gray-400">Arrow Up/Down:</span><span class="font-medium">Volume ±10%</span></div>
          <div class="flex justify-between"><span class="text-gray-400">F:</span><span class="font-medium">Fullscreen</span></div>
          <div class="flex justify-between"><span class="text-gray-400">M:</span><span class="font-medium">Mute</span></div>
        </div>
      </div>

      <div class="bg-gray-800 p-4 rounded-lg">
        <h3 class="text-lg font-semibold text-amber-400 mb-2">Resume Options</h3>
        <div class="space-y-3">
          <button id="resume-btn" class="w-full bg-amber-500 hover:bg-amber-600 text-black font-medium py-2 px-4 rounded transition"><i class="fas fa-play-circle mr-2"></i> Resume from last position</button>
          <button id="restart-btn" class="w-full bg-gray-700 hover:bg-gray-600 text-white font-medium py-2 px-4 rounded transition"><i class="fas fa-redo mr-2"></i> Restart from beginning</button>
          <div class="text-xs text-gray-400 mt-2">Your progress is automatically saved every 10 seconds.</div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // URL params
    const params = new URLSearchParams(window.location.search);
    const title = params.get('title') || 'Movie';
    const videoUrl = params.get('video') || '';
    const subtitleUrl = params.get('subtitle') || '';
    const drmLicenseUrl = params.get('license') || ''; // optional explicit license server URL
    const saveKey = `continue-${title}`;

    // DOM
    const video = document.getElementById('video');
    const movieTitle = document.getElementById('movie-title');
    const loadingOverlay = document.getElementById('loading-overlay');
    const loadingText = document.getElementById('loading-text');
    const loadingDetails = document.getElementById('loading-details');
    const progressContainer = document.getElementById('progress-container');
    const progressBar = document.getElementById('progress-bar');
    const currentTimeDisplay = document.getElementById('current-time');
    const durationDisplay = document.getElementById('duration');
    const currentPosition = document.getElementById('current-position');
    const remainingTime = document.getElementById('remaining-time');
    const currentSpeed = document.getElementById('current-speed');
    const currentQuality = document.getElementById('current-quality');
    const playPauseBtn = document.getElementById('play-pause');
    const rewindBtn = document.getElementById('rewind');
    const forwardBtn = document.getElementById('forward');
    const volumeBtn = document.getElementById('volume-btn');
    const volumeSlider = document.getElementById('volume-slider');
    const mobileVolumeSlider = document.getElementById('mobile-volume-slider');
    const volumeContainer = document.getElementById('volume-container');
    const speedBtn = document.getElementById('speed-btn');
    const speedMenu = document.getElementById('speed-menu');
    const subtitleBtn = document.getElementById('subtitle-btn');
    const subtitleMenu = document.getElementById('subtitle-menu');
    const qualityBtn = document.getElementById('quality-btn');
    const qualityMenu = document.getElementById('quality-menu');
    const fullscreenBtn = document.getElementById('fullscreen-btn');
    const resumeBtn = document.getElementById('resume-btn');
    const restartBtn = document.getElementById('restart-btn');
    const streamInfo = document.getElementById('stream-info');
    const videoContainer = document.getElementById('video-container');

    // State
    let isDraggingProgress = false;
    let hls;
    let dashPlayer;
    let lastVolume = 1;
    let controlsTimeout;
    let isSettingsMenuOpen = false;

    // helpers
    function showLoading(message, details = '') {
      loadingOverlay.style.display = 'flex';
      loadingText.textContent = message || 'Loading...';
      loadingDetails.textContent = details || 'Please wait while we prepare your viewing experience';
    }
    function hideLoading() { loadingOverlay.style.display = 'none'; }

    document.addEventListener('DOMContentLoaded', initPlayer);

    function initPlayer() {
      movieTitle.textContent = title || 'Movie Player';
      setupEventListeners();
      loadVideoAuto();
    }

    // --------------------
    // AUTO DETECT + LOAD
    // --------------------
    async function loadVideoAuto() {
      if (!videoUrl) {
        showLoading('No video URL provided.');
        return;
      }

      showLoading('Detecting stream type...', videoUrl);

      // quick type heuristics
      const isMPD = videoUrl.includes('.mpd');
      const isM3U8 = videoUrl.includes('.m3u8');

      try {
        if (isMPD) {
          await handleDASH(videoUrl);
        } else if (isM3U8) {
          await handleHLS(videoUrl);
        } else {
          // fallback: try HEAD to get content-type, else try to fetch small chunk of URL
          const type = await probeContentType(videoUrl);
          if (type && type.includes('mpd')) {
            await handleDASH(videoUrl);
          } else if (type && (type.includes('mpegurl') || type.includes('application/vnd.apple.mpegurl') || type.includes('m3u8'))) {
            await handleHLS(videoUrl);
          } else {
            // try to set as direct src (mp4 etc)
            if (video.canPlayType(type || 'video/mp4')) {
              video.src = videoUrl;
              attachSubtitleIfAny();
              hideLoading();
              video.play().catch(()=>{});
            } else {
              showLoading('Unsupported or unknown stream type.');
            }
          }
        }
      } catch (err) {
        console.error('loadVideoAuto error', err);
        showLoading('Error loading stream. See console for details.');
      }
    }

    // attempt to get Content-Type with HEAD or fetch small portion
    async function probeContentType(url) {
      try {
        const resp = await fetch(url, { method: 'HEAD' });
        const ct = resp.headers.get('content-type');
        if (ct) return ct;
      } catch (e) {
        // HEAD may be blocked by CORS or server; fall through to GET small chunk
      }

      try {
        const resp = await fetch(url, { method: 'GET', headers: { Range: 'bytes=0-1023' } });
        const ct = resp.headers.get('content-type');
        if (ct) return ct;
        const text = await resp.text();
        if (text.includes('<?xml') && text.includes('MPD')) return 'application/dash+xml';
        if (text.includes('#EXTM3U')) return 'application/vnd.apple.mpegurl';
      } catch (e) {
        // ignore
      }
      return '';
    }

    // --------------------
    // DASH handler (with DRM detection & license auto-extraction)
    // --------------------
    async function handleDASH(url) {
      showLoading('Detected DASH (.mpd). Fetching manifest to inspect DRM...');
      let mpdText = '';
      try {
        const r = await fetch(url, { method: 'GET' });
        mpdText = await r.text();
      } catch (err) {
        console.warn('Could not fetch MPD (CORS?)', err);
        // still try to init dash player without manifest parsing
        return initDash(url, null);
      }

      // parse xml to detect ContentProtection and license URLs
      let drmInfo = { isEncrypted: false, widevine: false, licenseFromMPD: '' };
      try {
        const parser = new DOMParser();
        const xml = parser.parseFromString(mpdText, 'application/xml');

        // look for ContentProtection elements
        const cps = xml.getElementsByTagName('ContentProtection');
        for (let i = 0; i < cps.length; i++) {
          const cp = cps[i];
          const scheme = cp.getAttribute('schemeIdUri') || cp.getAttribute('value') || '';
          const inner = cp.textContent || '';

          // Widevine UUID
          if (scheme && scheme.toLowerCase().includes('edef8ba9')) {
            drmInfo.isEncrypted = true;
            drmInfo.widevine = true;
          }
          if ((inner && inner.toLowerCase().includes('widevine')) || (scheme && scheme.toLowerCase().includes('widevine'))) {
            drmInfo.isEncrypted = true;
            drmInfo.widevine = true;
          }

          // Some MPDs embed license URL or laurl elements (rare). Try to find attributes or children
          // e.g. <ContentProtection ...><widevine:license xmlns:widevine="...">https://lic.example/</widevine:license></ContentProtection>
          if (inner && inner.match(/https?:\/\/[^\s'"]+/)) {
            const found = inner.match(/https?:\/\/[^\s'"]+/g);
            // pick the one that contains 'license' or 'drm' preferably
            if (found && found.length) {
              const pick = found.find(s => /license|drm|widevine|rights/i.test(s)) || found[0];
              drmInfo.licenseFromMPD = pick;
            }
          }

          // try attributes
          const attrString = cp.outerHTML || '';
          const attrMatch = attrString.match(/https?:\/\/[^\s'"]+/g);
          if (attrMatch && attrMatch.length) {
            const pick = attrMatch.find(s => /license|drm|widevine|rights/i.test(s)) || attrMatch[0];
            if (!drmInfo.licenseFromMPD) drmInfo.licenseFromMPD = pick;
          }
        }

        // Also search entire MPD text for license-like urls
        if (!drmInfo.licenseFromMPD) {
          const allUrls = mpdText.match(/https?:\/\/[^\s'"]+/g) || [];
          if (allUrls.length) {
            const candidate = allUrls.find(s => /license|drm|widevine|rights|laurl/i.test(s));
            if (candidate) drmInfo.licenseFromMPD = candidate;
          }
        }
      } catch (e) {
        console.warn('MPD parse failed', e);
      }

      // show info
      if (drmInfo.isEncrypted) {
        showLoading('DASH manifest indicates DRM-protected content.', drmInfo.widevine ? 'Widevine detected' : 'Encrypted content detected');
      } else {
        showLoading('DASH manifest loaded — no DRM detected (attempting playback).');
      }

      // decide license URL to use
      let licenseToUse = '';

      if (drmLicenseUrl) {
        licenseToUse = drmLicenseUrl;
      } else if (drmInfo.licenseFromMPD) {
        licenseToUse = drmInfo.licenseFromMPD;
      }

      // initialize dash
      await initDash(url, licenseToUse, drmInfo);
    }

    // initialize dash.js player; license may be null
    async function initDash(url, licenseUrl, drmInfo = {}) {
      // dynamically load dash.js
      showLoading('Initializing DASH player...');
      if (typeof dashjs === 'undefined' && typeof window.dashjs === 'undefined') {
        await new Promise((res) => {
          const s = document.createElement('script');
          s.src = 'https://cdn.dashjs.org/latest/dash.all.min.js';
          s.onload = res;
          s.onerror = res;
          document.body.appendChild(s);
        });
      }

      try {
        // destroy existing if present
        if (dashPlayer && dashPlayer.destroy) dashPlayer.reset();

        dashPlayer = dashjs.MediaPlayer().create();
        dashPlayer.initialize(video, null, false); // we'll attach source below

        // If license known and Widevine, set protection data
        if (licenseUrl && drmInfo.widevine) {
          dashPlayer.setProtectionData({
            "com.widevine.alpha": { "serverURL": licenseUrl }
          });
          streamInfo.style.display = 'block';
          streamInfo.textContent = 'DRM: Widevine (using license from MPD or query)';
        } else if (drmInfo.isEncrypted && drmInfo.widevine && !licenseUrl) {
          // DRM detected but no license URL found -> inform user but still attach and let browser/player fail gracefully
          streamInfo.style.display = 'block';
          streamInfo.textContent = 'DRM: Widevine detected — no license URL found. Provide ?license=LICENSE_URL to play.';
        } else {
          streamInfo.style.display = 'block';
          streamInfo.textContent = 'DASH (unencrypted)';
        }

        dashPlayer.attachSource(url);
        dashPlayer.play();

        // restore last position if any
        const lastTime = localStorage.getItem(saveKey);
        if (lastTime) {
          video.addEventListener('loadedmetadata', () => {
            try { video.currentTime = parseFloat(lastTime); } catch(e){}
          }, { once: true });
        }

        hideLoading();
      } catch (err) {
        console.error('dash init failed', err);
        showLoading('DASH player initialization failed. See console for details.');
      }
    }

    // --------------------
    // HLS handler
    // --------------------
    async function handleHLS(url) {
      showLoading('Detected HLS (.m3u8). Initializing HLS playback...');
      try {
        if (Hls && Hls.isSupported()) {
          if (hls) { hls.destroy(); hls = null; }
          hls = new Hls({
            maxBufferLength: 30,
            maxMaxBufferLength: 600,
            maxBufferSize: 60 * 1000 * 1000,
            enableWorker: true,
            lowLatencyMode: false,
            backBufferLength: 30
          });
          hls.loadSource(url);
          hls.attachMedia(video);

          hls.on(Hls.Events.MANIFEST_PARSED, (event, data) => {
            // populate quality menu
            const qualityMenuEl = document.getElementById('quality-menu');
            const levels = data.levels || [];
            qualityMenuEl.innerHTML = `<div class="quality-option px-3 py-2 cursor-pointer" data-quality="auto">Auto</div>
              ${levels.map(level => `<div class="quality-option px-3 py-2 cursor-pointer" data-quality="${level.height}">${level.height}p</div>`).join('')}`;

            // rebind options
            document.querySelectorAll('.quality-option').forEach(option => {
              option.addEventListener('click', () => {
                const quality = option.dataset.quality;
                if (quality === 'auto') { hls.currentLevel = -1; }
                else {
                  for (let i=0;i<hls.levels.length;i++){
                    if (hls.levels[i].height <= parseInt(quality)) { hls.currentLevel = i; break; }
                  }
                }
                currentQuality.textContent = quality === 'auto' ? 'Auto' : `${quality}p`;
                document.getElementById('quality-menu').classList.remove('active');
              });
            });

            // subtitle track injection if provided
            attachSubtitleIfAny();

            hideLoading();
            video.play().catch(()=>{});
          });

          hls.on(Hls.Events.ERROR, (event, data) => {
            console.warn('hls error', data);
            if (data.fatal) {
              switch(data.type) {
                case Hls.ErrorTypes.NETWORK_ERROR:
                  showLoading('Network error — retrying...');
                  hls.startLoad();
                  break;
                case Hls.ErrorTypes.MEDIA_ERROR:
                  showLoading('Media error — attempting recovery...');
                  hls.recoverMediaError();
                  break;
                default:
                  showLoading('Fatal error while playing HLS.');
                  break;
              }
            }
          });
        } else if (video.canPlayType && video.canPlayType('application/vnd.apple.mpegurl')) {
          // native Safari
          video.src = url;
          attachSubtitleIfAny();
          video.addEventListener('loadedmetadata', () => {
            hideLoading();
            video.play().catch(()=>{});
          }, { once: true });
        } else {
          showLoading('HLS not supported by this browser.');
        }
      } catch (err) {
        console.error('handleHLS error', err);
        showLoading('Error initializing HLS playback.');
      }
    }

    // attach subtitle if provided
    function attachSubtitleIfAny() {
      if (subtitleUrl) {
        // remove existing tracks
        const existing = Array.from(video.querySelectorAll('track'));
        existing.forEach(t => t.remove());

        const track = document.createElement('track');
        track.kind = 'subtitles';
        track.label = 'English';
        track.srclang = 'en';
        track.src = subtitleUrl;
        track.default = true;
        video.appendChild(track);

        // rebuild subtitle menu
        const subtitleMenuEl = document.getElementById('subtitle-menu');
        subtitleMenuEl.innerHTML = `
          <div class="subtitle-option px-3 py-2 cursor-pointer" data-subtitle="none">None</div>
          <div class="subtitle-option px-3 py-2 cursor-pointer" data-subtitle="en">English</div>
        `;
        document.querySelectorAll('.subtitle-option').forEach(option => {
          option.addEventListener('click', () => {
            const subtitle = option.dataset.subtitle;
            if (subtitle === 'none') {
              for (const track of video.textTracks) track.mode = 'hidden';
            } else {
              for (const track of video.textTracks) {
                track.mode = track.language === subtitle ? 'showing' : 'hidden';
              }
            }
            subtitleMenu.classList.remove('active');
          });
        });
      }
    }

    // --------------------
    // UI & Controls
    // --------------------
    function setupEventListeners() {
      // basic video events
      video.addEventListener('timeupdate', updateProgress);
      video.addEventListener('loadedmetadata', updateDuration);
      video.addEventListener('play', onPlay);
      video.addEventListener('pause', onPause);
      video.addEventListener('volumechange', updateVolumeIcon);
      video.addEventListener('click', togglePlayPause);
      video.addEventListener('dblclick', toggleFullscreen);
      video.addEventListener('webkitbeginfullscreen', () => document.body.classList.add('fullscreen'));
      video.addEventListener('webkitendfullscreen', () => document.body.classList.remove('fullscreen'));

      // control buttons
      playPauseBtn.addEventListener('click', togglePlayPause);
      rewindBtn.addEventListener('click', () => seek(-10));
      forwardBtn.addEventListener('click', () => seek(10));
      volumeBtn.addEventListener('click', toggleMute);
      volumeSlider.addEventListener('input', updateVolume);
      mobileVolumeSlider.addEventListener('input', updateVolume);
      fullscreenBtn.addEventListener('click', toggleFullscreen);
      resumeBtn.addEventListener('click', resumeFromLastPosition);
      restartBtn.addEventListener('click', restartFromBeginning);

      // progress interactions
      progressContainer.addEventListener('mousedown', startDraggingProgress);
      progressContainer.addEventListener('touchstart', startDraggingProgress, { passive: false });
      document.addEventListener('mousemove', dragProgress);
      document.addEventListener('touchmove', dragProgress, { passive: false });
      document.addEventListener('mouseup', stopDraggingProgress);
      document.addEventListener('touchend', stopDraggingProgress);

      // settings menu toggles
      speedBtn.addEventListener('click', () => toggleMenu(speedMenu));
      subtitleBtn.addEventListener('click', () => toggleMenu(subtitleMenu));
      qualityBtn.addEventListener('click', () => toggleMenu(qualityMenu));

      // click outside to close menus
      document.addEventListener('click', (e) => {
        if (!speedBtn.contains(e.target) && !speedMenu.contains(e.target)) speedMenu.classList.remove('active');
        if (!subtitleBtn.contains(e.target) && !subtitleMenu.contains(e.target)) subtitleMenu.classList.remove('active');
        if (!qualityBtn.contains(e.target) && !qualityMenu.contains(e.target)) qualityMenu.classList.remove('active');
      });

      // keyboard shortcuts
      document.addEventListener('keydown', handleKeyboardShortcuts);

      // show/hide controls on activity
      const activityHandler = () => showControlsTemporarily();
      document.addEventListener('mousemove', activityHandler);
      document.addEventListener('touchstart', activityHandler, { passive: true });
      document.addEventListener('keydown', activityHandler);

      // volume hover
      volumeBtn.addEventListener('mouseenter', () => volumeContainer.classList.add('active'));
      volumeContainer.addEventListener('mouseleave', () => {
        if (!volumeContainer.contains(document.activeElement)) volumeContainer.classList.remove('active');
      });

      // speed options
      document.querySelectorAll('.speed-option').forEach(option => {
        option.addEventListener('click', () => {
          const speed = parseFloat(option.dataset.speed);
          video.playbackRate = speed;
          speedBtn.querySelector('span').textContent = `${speed}x`;
          currentSpeed.textContent = `${speed}x`;
          speedMenu.classList.remove('active');
        });
      });

      // quality default options (hls will overwrite when available)
      document.querySelectorAll('.quality-option').forEach(option => {
        option.addEventListener('click', () => {
          const quality = option.dataset.quality;
          if (hls) {
            if (quality === 'auto') hls.currentLevel = -1;
            else {
              const levels = hls.levels;
              for (let i = 0; i < levels.length; i++) {
                if (levels[i].height <= parseInt(quality)) { hls.currentLevel = i; break; }
              }
            }
            currentQuality.textContent = quality === 'auto' ? 'Auto' : `${quality}p`;
          }
          qualityMenu.classList.remove('active');
        });
      });

      // save on exit
      window.addEventListener('beforeunload', () => {
        if (!isNaN(video.currentTime)) localStorage.setItem(saveKey, video.currentTime);
      });

      // fullscreenchange
      document.addEventListener('fullscreenchange', () => showControlsTemporarily());
    }

    // play / pause
    function togglePlayPause() {
      if (video.paused) video.play().catch(()=>{});
      else video.pause();
    }
    function onPlay(){ updatePlayPauseIcon(); showControlsTemporarily(); }
    function onPause(){ updatePlayPauseIcon(); clearTimeout(controlsTimeout); document.getElementById('controls-container').style.opacity = '1'; }
    function updatePlayPauseIcon(){
      const icon = playPauseBtn.querySelector('i');
      if (!icon) return;
      if (video.paused) icon.classList.replace('fa-pause','fa-play'); else icon.classList.replace('fa-play','fa-pause');
    }

    // seek and progress
    function seek(seconds){ video.currentTime += seconds; }
    function updateProgress(){
      if (!isDraggingProgress && video.duration) {
        const progress = (video.currentTime / video.duration) * 100;
        progressBar.style.width = `${progress}%`;
      }
      currentTimeDisplay.textContent = formatTime(video.currentTime || 0);
      durationDisplay.textContent = formatTime(video.duration || 0);
      currentPosition.textContent = formatTime(video.currentTime || 0);
      remainingTime.textContent = formatTime((video.duration || 0) - (video.currentTime || 0));
      if (!isNaN(video.currentTime) && (video.currentTime % 10) < 0.1) localStorage.setItem(saveKey, video.currentTime);
    }
    function updateDuration(){ durationDisplay.textContent = formatTime(video.duration || 0); remainingTime.textContent = formatTime(video.duration || 0); }

    // drag handlers
    function startDraggingProgress(e){ e.preventDefault(); isDraggingProgress = true; updateProgressOnDrag(e); }
    function dragProgress(e){ if (isDraggingProgress) updateProgressOnDrag(e); }
    function stopDraggingProgress(){ isDraggingProgress = false; }
    function updateProgressOnDrag(e){
      const rect = progressContainer.getBoundingClientRect();
      const clientX = (e.touches && e.touches[0]) ? e.touches[0].clientX : (e.clientX || 0);
      const pos = clientX - rect.left;
      const percent = Math.min(Math.max(pos / rect.width, 0), 1);
      progressBar.style.width = `${percent * 100}%`;
      if (video.duration) video.currentTime = percent * video.duration;
    }

    // volume
    function toggleMute() {
      if (video.volume > 0) { lastVolume = video.volume; video.volume = 0; volumeSlider.value = 0; mobileVolumeSlider.value = 0; }
      else { video.volume = lastVolume; volumeSlider.value = lastVolume; mobileVolumeSlider.value = lastVolume; }
    }
    function updateVolume(e) {
      const value = (typeof this.value !== 'undefined') ? this.value : (event && event.target ? event.target.value : 1);
      video.volume = value;
      volumeSlider.value = value;
      if (mobileVolumeSlider) mobileVolumeSlider.value = value;
      lastVolume = value;
    }
    function updateVolumeIcon() {
      const icon = volumeBtn.querySelector('i');
      if (!icon) return;
      if (video.volume === 0 || video.muted) { icon.className = 'fas fa-volume-mute text-lg'; }
      else if (video.volume < 0.5) { icon.className = 'fas fa-volume-down text-lg'; }
      else { icon.className = 'fas fa-volume-up text-lg'; }
    }

    // fullscreen
    function toggleFullscreen() {
      if (!document.fullscreenElement) {
        videoContainer.requestFullscreen().then(() => {
          if (screen.orientation && screen.orientation.lock) {
            screen.orientation.lock('landscape').catch(()=>{});
          }
        }).catch(err => {});
      } else {
        document.exitFullscreen();
        if (screen.orientation && screen.orientation.unlock) screen.orientation.unlock();
      }
    }

    // menus
    function toggleMenu(menu) {
      isSettingsMenuOpen = !menu.classList.contains('active');
      document.querySelectorAll('.settings-menu').forEach(m => m.classList.remove('active'));
      if (isSettingsMenuOpen) menu.classList.add('active');
    }

    function showControlsTemporarily() {
      const controls = document.getElementById('controls-container');
      controls.style.opacity = '1';
      clearTimeout(controlsTimeout);
      if (!video.paused) {
        controlsTimeout = setTimeout(()=>{ controls.style.opacity = '0'; }, 3000);
      }
    }

    // resume/restart
    function resumeFromLastPosition() {
      const lastTime = localStorage.getItem(saveKey);
      if (lastTime) video.currentTime = parseFloat(lastTime);
      video.play().catch(()=>{});
    }
    function restartFromBeginning() {
      video.currentTime = 0;
      localStorage.removeItem(saveKey);
      video.play().catch(()=>{});
    }

    // keyboard
    function handleKeyboardShortcuts(e) {
      switch(e.key) {
        case ' ':
          e.preventDefault();
          togglePlayPause();
          break;
        case 'ArrowLeft':
          e.preventDefault();
          seek(-10);
          break;
        case 'ArrowRight':
          e.preventDefault();
          seek(10);
          break;
        case 'ArrowUp':
          e.preventDefault();
          video.volume = Math.min(video.volume + 0.1, 1);
          volumeSlider.value = video.volume;
          mobileVolumeSlider.value = video.volume;
          lastVolume = video.volume;
          break;
        case 'ArrowDown':
          e.preventDefault();
          video.volume = Math.max(video.volume - 0.1, 0);
          volumeSlider.value = video.volume;
          mobileVolumeSlider.value = video.volume;
          lastVolume = video.volume;
          break;
        case 'f':
        case 'F':
          toggleFullscreen();
          break;
        case 'm':
        case 'M':
          toggleMute();
          break;
      }
    }

    function formatTime(seconds) {
      if (!seconds || isNaN(seconds) || seconds < 0) return '0:00';
      const h = Math.floor(seconds / 3600);
      const m = Math.floor((seconds % 3600) / 60);
      const s = Math.floor(seconds % 60);
      return h > 0 ? `${h}:${m < 10 ? '0'+m : m}:${s < 10 ? '0'+s : s}` : `${m}:${s < 10 ? '0'+s : s}`;
    }

  </script>
</body>
</html>
